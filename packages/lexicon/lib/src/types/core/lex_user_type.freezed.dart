// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'lex_user_type.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$LexUserType {
  Object get data => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LexRecord data) record,
    required TResult Function(LexXrpcQuery data) xrpcQuery,
    required TResult Function(LexXrpcProcedure data) xrpcProcedure,
    required TResult Function(LexXrpcSubscription data) xrpcSubscription,
    required TResult Function(LexBlob data) blob,
    required TResult Function(LexArray data) array,
    required TResult Function(LexToken data) token,
    required TResult Function(LexObject data) object,
    required TResult Function(LexBoolean data) boolean,
    required TResult Function(LexInteger data) integer,
    required TResult Function(LexString data) string,
    required TResult Function(LexBytes data) bytes,
    required TResult Function(LexCidLink data) cidLink,
    required TResult Function(LexUnknown data) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LexRecord data)? record,
    TResult? Function(LexXrpcQuery data)? xrpcQuery,
    TResult? Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult? Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult? Function(LexBlob data)? blob,
    TResult? Function(LexArray data)? array,
    TResult? Function(LexToken data)? token,
    TResult? Function(LexObject data)? object,
    TResult? Function(LexBoolean data)? boolean,
    TResult? Function(LexInteger data)? integer,
    TResult? Function(LexString data)? string,
    TResult? Function(LexBytes data)? bytes,
    TResult? Function(LexCidLink data)? cidLink,
    TResult? Function(LexUnknown data)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LexRecord data)? record,
    TResult Function(LexXrpcQuery data)? xrpcQuery,
    TResult Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult Function(LexBlob data)? blob,
    TResult Function(LexArray data)? array,
    TResult Function(LexToken data)? token,
    TResult Function(LexObject data)? object,
    TResult Function(LexBoolean data)? boolean,
    TResult Function(LexInteger data)? integer,
    TResult Function(LexString data)? string,
    TResult Function(LexBytes data)? bytes,
    TResult Function(LexCidLink data)? cidLink,
    TResult Function(LexUnknown data)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ULexUserTypeRecord value) record,
    required TResult Function(ULexUserTypeXrpcQuery value) xrpcQuery,
    required TResult Function(ULexUserTypeXrpcProcedure value) xrpcProcedure,
    required TResult Function(ULexUserTypeXrpcSubscription value)
        xrpcSubscription,
    required TResult Function(ULexUserTypeBlob value) blob,
    required TResult Function(ULexUserTypeArray value) array,
    required TResult Function(ULexUserTypeToken value) token,
    required TResult Function(ULexUserTypeObject value) object,
    required TResult Function(ULexUserTypeBoolean value) boolean,
    required TResult Function(ULexUserTypeInteger value) integer,
    required TResult Function(ULexUserTypeString value) string,
    required TResult Function(ULexUserTypeBytes value) bytes,
    required TResult Function(ULexUserTypeCidLink value) cidLink,
    required TResult Function(ULexUserTypeUnknown value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ULexUserTypeRecord value)? record,
    TResult? Function(ULexUserTypeXrpcQuery value)? xrpcQuery,
    TResult? Function(ULexUserTypeXrpcProcedure value)? xrpcProcedure,
    TResult? Function(ULexUserTypeXrpcSubscription value)? xrpcSubscription,
    TResult? Function(ULexUserTypeBlob value)? blob,
    TResult? Function(ULexUserTypeArray value)? array,
    TResult? Function(ULexUserTypeToken value)? token,
    TResult? Function(ULexUserTypeObject value)? object,
    TResult? Function(ULexUserTypeBoolean value)? boolean,
    TResult? Function(ULexUserTypeInteger value)? integer,
    TResult? Function(ULexUserTypeString value)? string,
    TResult? Function(ULexUserTypeBytes value)? bytes,
    TResult? Function(ULexUserTypeCidLink value)? cidLink,
    TResult? Function(ULexUserTypeUnknown value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ULexUserTypeRecord value)? record,
    TResult Function(ULexUserTypeXrpcQuery value)? xrpcQuery,
    TResult Function(ULexUserTypeXrpcProcedure value)? xrpcProcedure,
    TResult Function(ULexUserTypeXrpcSubscription value)? xrpcSubscription,
    TResult Function(ULexUserTypeBlob value)? blob,
    TResult Function(ULexUserTypeArray value)? array,
    TResult Function(ULexUserTypeToken value)? token,
    TResult Function(ULexUserTypeObject value)? object,
    TResult Function(ULexUserTypeBoolean value)? boolean,
    TResult Function(ULexUserTypeInteger value)? integer,
    TResult Function(ULexUserTypeString value)? string,
    TResult Function(ULexUserTypeBytes value)? bytes,
    TResult Function(ULexUserTypeCidLink value)? cidLink,
    TResult Function(ULexUserTypeUnknown value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LexUserTypeCopyWith<$Res> {
  factory $LexUserTypeCopyWith(
          LexUserType value, $Res Function(LexUserType) then) =
      _$LexUserTypeCopyWithImpl<$Res, LexUserType>;
}

/// @nodoc
class _$LexUserTypeCopyWithImpl<$Res, $Val extends LexUserType>
    implements $LexUserTypeCopyWith<$Res> {
  _$LexUserTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$ULexUserTypeRecordImplCopyWith<$Res> {
  factory _$$ULexUserTypeRecordImplCopyWith(_$ULexUserTypeRecordImpl value,
          $Res Function(_$ULexUserTypeRecordImpl) then) =
      __$$ULexUserTypeRecordImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LexRecord data});

  $LexRecordCopyWith<$Res> get data;
}

/// @nodoc
class __$$ULexUserTypeRecordImplCopyWithImpl<$Res>
    extends _$LexUserTypeCopyWithImpl<$Res, _$ULexUserTypeRecordImpl>
    implements _$$ULexUserTypeRecordImplCopyWith<$Res> {
  __$$ULexUserTypeRecordImplCopyWithImpl(_$ULexUserTypeRecordImpl _value,
      $Res Function(_$ULexUserTypeRecordImpl) _then)
      : super(_value, _then);

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$ULexUserTypeRecordImpl(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as LexRecord,
    ));
  }

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LexRecordCopyWith<$Res> get data {
    return $LexRecordCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc

class _$ULexUserTypeRecordImpl extends ULexUserTypeRecord {
  const _$ULexUserTypeRecordImpl({required this.data}) : super._();

  @override
  final LexRecord data;

  @override
  String toString() {
    return 'LexUserType.record(data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ULexUserTypeRecordImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ULexUserTypeRecordImplCopyWith<_$ULexUserTypeRecordImpl> get copyWith =>
      __$$ULexUserTypeRecordImplCopyWithImpl<_$ULexUserTypeRecordImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LexRecord data) record,
    required TResult Function(LexXrpcQuery data) xrpcQuery,
    required TResult Function(LexXrpcProcedure data) xrpcProcedure,
    required TResult Function(LexXrpcSubscription data) xrpcSubscription,
    required TResult Function(LexBlob data) blob,
    required TResult Function(LexArray data) array,
    required TResult Function(LexToken data) token,
    required TResult Function(LexObject data) object,
    required TResult Function(LexBoolean data) boolean,
    required TResult Function(LexInteger data) integer,
    required TResult Function(LexString data) string,
    required TResult Function(LexBytes data) bytes,
    required TResult Function(LexCidLink data) cidLink,
    required TResult Function(LexUnknown data) unknown,
  }) {
    return record(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LexRecord data)? record,
    TResult? Function(LexXrpcQuery data)? xrpcQuery,
    TResult? Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult? Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult? Function(LexBlob data)? blob,
    TResult? Function(LexArray data)? array,
    TResult? Function(LexToken data)? token,
    TResult? Function(LexObject data)? object,
    TResult? Function(LexBoolean data)? boolean,
    TResult? Function(LexInteger data)? integer,
    TResult? Function(LexString data)? string,
    TResult? Function(LexBytes data)? bytes,
    TResult? Function(LexCidLink data)? cidLink,
    TResult? Function(LexUnknown data)? unknown,
  }) {
    return record?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LexRecord data)? record,
    TResult Function(LexXrpcQuery data)? xrpcQuery,
    TResult Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult Function(LexBlob data)? blob,
    TResult Function(LexArray data)? array,
    TResult Function(LexToken data)? token,
    TResult Function(LexObject data)? object,
    TResult Function(LexBoolean data)? boolean,
    TResult Function(LexInteger data)? integer,
    TResult Function(LexString data)? string,
    TResult Function(LexBytes data)? bytes,
    TResult Function(LexCidLink data)? cidLink,
    TResult Function(LexUnknown data)? unknown,
    required TResult orElse(),
  }) {
    if (record != null) {
      return record(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ULexUserTypeRecord value) record,
    required TResult Function(ULexUserTypeXrpcQuery value) xrpcQuery,
    required TResult Function(ULexUserTypeXrpcProcedure value) xrpcProcedure,
    required TResult Function(ULexUserTypeXrpcSubscription value)
        xrpcSubscription,
    required TResult Function(ULexUserTypeBlob value) blob,
    required TResult Function(ULexUserTypeArray value) array,
    required TResult Function(ULexUserTypeToken value) token,
    required TResult Function(ULexUserTypeObject value) object,
    required TResult Function(ULexUserTypeBoolean value) boolean,
    required TResult Function(ULexUserTypeInteger value) integer,
    required TResult Function(ULexUserTypeString value) string,
    required TResult Function(ULexUserTypeBytes value) bytes,
    required TResult Function(ULexUserTypeCidLink value) cidLink,
    required TResult Function(ULexUserTypeUnknown value) unknown,
  }) {
    return record(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ULexUserTypeRecord value)? record,
    TResult? Function(ULexUserTypeXrpcQuery value)? xrpcQuery,
    TResult? Function(ULexUserTypeXrpcProcedure value)? xrpcProcedure,
    TResult? Function(ULexUserTypeXrpcSubscription value)? xrpcSubscription,
    TResult? Function(ULexUserTypeBlob value)? blob,
    TResult? Function(ULexUserTypeArray value)? array,
    TResult? Function(ULexUserTypeToken value)? token,
    TResult? Function(ULexUserTypeObject value)? object,
    TResult? Function(ULexUserTypeBoolean value)? boolean,
    TResult? Function(ULexUserTypeInteger value)? integer,
    TResult? Function(ULexUserTypeString value)? string,
    TResult? Function(ULexUserTypeBytes value)? bytes,
    TResult? Function(ULexUserTypeCidLink value)? cidLink,
    TResult? Function(ULexUserTypeUnknown value)? unknown,
  }) {
    return record?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ULexUserTypeRecord value)? record,
    TResult Function(ULexUserTypeXrpcQuery value)? xrpcQuery,
    TResult Function(ULexUserTypeXrpcProcedure value)? xrpcProcedure,
    TResult Function(ULexUserTypeXrpcSubscription value)? xrpcSubscription,
    TResult Function(ULexUserTypeBlob value)? blob,
    TResult Function(ULexUserTypeArray value)? array,
    TResult Function(ULexUserTypeToken value)? token,
    TResult Function(ULexUserTypeObject value)? object,
    TResult Function(ULexUserTypeBoolean value)? boolean,
    TResult Function(ULexUserTypeInteger value)? integer,
    TResult Function(ULexUserTypeString value)? string,
    TResult Function(ULexUserTypeBytes value)? bytes,
    TResult Function(ULexUserTypeCidLink value)? cidLink,
    TResult Function(ULexUserTypeUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (record != null) {
      return record(this);
    }
    return orElse();
  }
}

abstract class ULexUserTypeRecord extends LexUserType {
  const factory ULexUserTypeRecord({required final LexRecord data}) =
      _$ULexUserTypeRecordImpl;
  const ULexUserTypeRecord._() : super._();

  @override
  LexRecord get data;

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ULexUserTypeRecordImplCopyWith<_$ULexUserTypeRecordImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ULexUserTypeXrpcQueryImplCopyWith<$Res> {
  factory _$$ULexUserTypeXrpcQueryImplCopyWith(
          _$ULexUserTypeXrpcQueryImpl value,
          $Res Function(_$ULexUserTypeXrpcQueryImpl) then) =
      __$$ULexUserTypeXrpcQueryImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LexXrpcQuery data});

  $LexXrpcQueryCopyWith<$Res> get data;
}

/// @nodoc
class __$$ULexUserTypeXrpcQueryImplCopyWithImpl<$Res>
    extends _$LexUserTypeCopyWithImpl<$Res, _$ULexUserTypeXrpcQueryImpl>
    implements _$$ULexUserTypeXrpcQueryImplCopyWith<$Res> {
  __$$ULexUserTypeXrpcQueryImplCopyWithImpl(_$ULexUserTypeXrpcQueryImpl _value,
      $Res Function(_$ULexUserTypeXrpcQueryImpl) _then)
      : super(_value, _then);

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$ULexUserTypeXrpcQueryImpl(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as LexXrpcQuery,
    ));
  }

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LexXrpcQueryCopyWith<$Res> get data {
    return $LexXrpcQueryCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc

class _$ULexUserTypeXrpcQueryImpl extends ULexUserTypeXrpcQuery {
  const _$ULexUserTypeXrpcQueryImpl({required this.data}) : super._();

  @override
  final LexXrpcQuery data;

  @override
  String toString() {
    return 'LexUserType.xrpcQuery(data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ULexUserTypeXrpcQueryImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ULexUserTypeXrpcQueryImplCopyWith<_$ULexUserTypeXrpcQueryImpl>
      get copyWith => __$$ULexUserTypeXrpcQueryImplCopyWithImpl<
          _$ULexUserTypeXrpcQueryImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LexRecord data) record,
    required TResult Function(LexXrpcQuery data) xrpcQuery,
    required TResult Function(LexXrpcProcedure data) xrpcProcedure,
    required TResult Function(LexXrpcSubscription data) xrpcSubscription,
    required TResult Function(LexBlob data) blob,
    required TResult Function(LexArray data) array,
    required TResult Function(LexToken data) token,
    required TResult Function(LexObject data) object,
    required TResult Function(LexBoolean data) boolean,
    required TResult Function(LexInteger data) integer,
    required TResult Function(LexString data) string,
    required TResult Function(LexBytes data) bytes,
    required TResult Function(LexCidLink data) cidLink,
    required TResult Function(LexUnknown data) unknown,
  }) {
    return xrpcQuery(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LexRecord data)? record,
    TResult? Function(LexXrpcQuery data)? xrpcQuery,
    TResult? Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult? Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult? Function(LexBlob data)? blob,
    TResult? Function(LexArray data)? array,
    TResult? Function(LexToken data)? token,
    TResult? Function(LexObject data)? object,
    TResult? Function(LexBoolean data)? boolean,
    TResult? Function(LexInteger data)? integer,
    TResult? Function(LexString data)? string,
    TResult? Function(LexBytes data)? bytes,
    TResult? Function(LexCidLink data)? cidLink,
    TResult? Function(LexUnknown data)? unknown,
  }) {
    return xrpcQuery?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LexRecord data)? record,
    TResult Function(LexXrpcQuery data)? xrpcQuery,
    TResult Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult Function(LexBlob data)? blob,
    TResult Function(LexArray data)? array,
    TResult Function(LexToken data)? token,
    TResult Function(LexObject data)? object,
    TResult Function(LexBoolean data)? boolean,
    TResult Function(LexInteger data)? integer,
    TResult Function(LexString data)? string,
    TResult Function(LexBytes data)? bytes,
    TResult Function(LexCidLink data)? cidLink,
    TResult Function(LexUnknown data)? unknown,
    required TResult orElse(),
  }) {
    if (xrpcQuery != null) {
      return xrpcQuery(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ULexUserTypeRecord value) record,
    required TResult Function(ULexUserTypeXrpcQuery value) xrpcQuery,
    required TResult Function(ULexUserTypeXrpcProcedure value) xrpcProcedure,
    required TResult Function(ULexUserTypeXrpcSubscription value)
        xrpcSubscription,
    required TResult Function(ULexUserTypeBlob value) blob,
    required TResult Function(ULexUserTypeArray value) array,
    required TResult Function(ULexUserTypeToken value) token,
    required TResult Function(ULexUserTypeObject value) object,
    required TResult Function(ULexUserTypeBoolean value) boolean,
    required TResult Function(ULexUserTypeInteger value) integer,
    required TResult Function(ULexUserTypeString value) string,
    required TResult Function(ULexUserTypeBytes value) bytes,
    required TResult Function(ULexUserTypeCidLink value) cidLink,
    required TResult Function(ULexUserTypeUnknown value) unknown,
  }) {
    return xrpcQuery(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ULexUserTypeRecord value)? record,
    TResult? Function(ULexUserTypeXrpcQuery value)? xrpcQuery,
    TResult? Function(ULexUserTypeXrpcProcedure value)? xrpcProcedure,
    TResult? Function(ULexUserTypeXrpcSubscription value)? xrpcSubscription,
    TResult? Function(ULexUserTypeBlob value)? blob,
    TResult? Function(ULexUserTypeArray value)? array,
    TResult? Function(ULexUserTypeToken value)? token,
    TResult? Function(ULexUserTypeObject value)? object,
    TResult? Function(ULexUserTypeBoolean value)? boolean,
    TResult? Function(ULexUserTypeInteger value)? integer,
    TResult? Function(ULexUserTypeString value)? string,
    TResult? Function(ULexUserTypeBytes value)? bytes,
    TResult? Function(ULexUserTypeCidLink value)? cidLink,
    TResult? Function(ULexUserTypeUnknown value)? unknown,
  }) {
    return xrpcQuery?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ULexUserTypeRecord value)? record,
    TResult Function(ULexUserTypeXrpcQuery value)? xrpcQuery,
    TResult Function(ULexUserTypeXrpcProcedure value)? xrpcProcedure,
    TResult Function(ULexUserTypeXrpcSubscription value)? xrpcSubscription,
    TResult Function(ULexUserTypeBlob value)? blob,
    TResult Function(ULexUserTypeArray value)? array,
    TResult Function(ULexUserTypeToken value)? token,
    TResult Function(ULexUserTypeObject value)? object,
    TResult Function(ULexUserTypeBoolean value)? boolean,
    TResult Function(ULexUserTypeInteger value)? integer,
    TResult Function(ULexUserTypeString value)? string,
    TResult Function(ULexUserTypeBytes value)? bytes,
    TResult Function(ULexUserTypeCidLink value)? cidLink,
    TResult Function(ULexUserTypeUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (xrpcQuery != null) {
      return xrpcQuery(this);
    }
    return orElse();
  }
}

abstract class ULexUserTypeXrpcQuery extends LexUserType {
  const factory ULexUserTypeXrpcQuery({required final LexXrpcQuery data}) =
      _$ULexUserTypeXrpcQueryImpl;
  const ULexUserTypeXrpcQuery._() : super._();

  @override
  LexXrpcQuery get data;

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ULexUserTypeXrpcQueryImplCopyWith<_$ULexUserTypeXrpcQueryImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ULexUserTypeXrpcProcedureImplCopyWith<$Res> {
  factory _$$ULexUserTypeXrpcProcedureImplCopyWith(
          _$ULexUserTypeXrpcProcedureImpl value,
          $Res Function(_$ULexUserTypeXrpcProcedureImpl) then) =
      __$$ULexUserTypeXrpcProcedureImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LexXrpcProcedure data});

  $LexXrpcProcedureCopyWith<$Res> get data;
}

/// @nodoc
class __$$ULexUserTypeXrpcProcedureImplCopyWithImpl<$Res>
    extends _$LexUserTypeCopyWithImpl<$Res, _$ULexUserTypeXrpcProcedureImpl>
    implements _$$ULexUserTypeXrpcProcedureImplCopyWith<$Res> {
  __$$ULexUserTypeXrpcProcedureImplCopyWithImpl(
      _$ULexUserTypeXrpcProcedureImpl _value,
      $Res Function(_$ULexUserTypeXrpcProcedureImpl) _then)
      : super(_value, _then);

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$ULexUserTypeXrpcProcedureImpl(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as LexXrpcProcedure,
    ));
  }

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LexXrpcProcedureCopyWith<$Res> get data {
    return $LexXrpcProcedureCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc

class _$ULexUserTypeXrpcProcedureImpl extends ULexUserTypeXrpcProcedure {
  const _$ULexUserTypeXrpcProcedureImpl({required this.data}) : super._();

  @override
  final LexXrpcProcedure data;

  @override
  String toString() {
    return 'LexUserType.xrpcProcedure(data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ULexUserTypeXrpcProcedureImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ULexUserTypeXrpcProcedureImplCopyWith<_$ULexUserTypeXrpcProcedureImpl>
      get copyWith => __$$ULexUserTypeXrpcProcedureImplCopyWithImpl<
          _$ULexUserTypeXrpcProcedureImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LexRecord data) record,
    required TResult Function(LexXrpcQuery data) xrpcQuery,
    required TResult Function(LexXrpcProcedure data) xrpcProcedure,
    required TResult Function(LexXrpcSubscription data) xrpcSubscription,
    required TResult Function(LexBlob data) blob,
    required TResult Function(LexArray data) array,
    required TResult Function(LexToken data) token,
    required TResult Function(LexObject data) object,
    required TResult Function(LexBoolean data) boolean,
    required TResult Function(LexInteger data) integer,
    required TResult Function(LexString data) string,
    required TResult Function(LexBytes data) bytes,
    required TResult Function(LexCidLink data) cidLink,
    required TResult Function(LexUnknown data) unknown,
  }) {
    return xrpcProcedure(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LexRecord data)? record,
    TResult? Function(LexXrpcQuery data)? xrpcQuery,
    TResult? Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult? Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult? Function(LexBlob data)? blob,
    TResult? Function(LexArray data)? array,
    TResult? Function(LexToken data)? token,
    TResult? Function(LexObject data)? object,
    TResult? Function(LexBoolean data)? boolean,
    TResult? Function(LexInteger data)? integer,
    TResult? Function(LexString data)? string,
    TResult? Function(LexBytes data)? bytes,
    TResult? Function(LexCidLink data)? cidLink,
    TResult? Function(LexUnknown data)? unknown,
  }) {
    return xrpcProcedure?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LexRecord data)? record,
    TResult Function(LexXrpcQuery data)? xrpcQuery,
    TResult Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult Function(LexBlob data)? blob,
    TResult Function(LexArray data)? array,
    TResult Function(LexToken data)? token,
    TResult Function(LexObject data)? object,
    TResult Function(LexBoolean data)? boolean,
    TResult Function(LexInteger data)? integer,
    TResult Function(LexString data)? string,
    TResult Function(LexBytes data)? bytes,
    TResult Function(LexCidLink data)? cidLink,
    TResult Function(LexUnknown data)? unknown,
    required TResult orElse(),
  }) {
    if (xrpcProcedure != null) {
      return xrpcProcedure(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ULexUserTypeRecord value) record,
    required TResult Function(ULexUserTypeXrpcQuery value) xrpcQuery,
    required TResult Function(ULexUserTypeXrpcProcedure value) xrpcProcedure,
    required TResult Function(ULexUserTypeXrpcSubscription value)
        xrpcSubscription,
    required TResult Function(ULexUserTypeBlob value) blob,
    required TResult Function(ULexUserTypeArray value) array,
    required TResult Function(ULexUserTypeToken value) token,
    required TResult Function(ULexUserTypeObject value) object,
    required TResult Function(ULexUserTypeBoolean value) boolean,
    required TResult Function(ULexUserTypeInteger value) integer,
    required TResult Function(ULexUserTypeString value) string,
    required TResult Function(ULexUserTypeBytes value) bytes,
    required TResult Function(ULexUserTypeCidLink value) cidLink,
    required TResult Function(ULexUserTypeUnknown value) unknown,
  }) {
    return xrpcProcedure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ULexUserTypeRecord value)? record,
    TResult? Function(ULexUserTypeXrpcQuery value)? xrpcQuery,
    TResult? Function(ULexUserTypeXrpcProcedure value)? xrpcProcedure,
    TResult? Function(ULexUserTypeXrpcSubscription value)? xrpcSubscription,
    TResult? Function(ULexUserTypeBlob value)? blob,
    TResult? Function(ULexUserTypeArray value)? array,
    TResult? Function(ULexUserTypeToken value)? token,
    TResult? Function(ULexUserTypeObject value)? object,
    TResult? Function(ULexUserTypeBoolean value)? boolean,
    TResult? Function(ULexUserTypeInteger value)? integer,
    TResult? Function(ULexUserTypeString value)? string,
    TResult? Function(ULexUserTypeBytes value)? bytes,
    TResult? Function(ULexUserTypeCidLink value)? cidLink,
    TResult? Function(ULexUserTypeUnknown value)? unknown,
  }) {
    return xrpcProcedure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ULexUserTypeRecord value)? record,
    TResult Function(ULexUserTypeXrpcQuery value)? xrpcQuery,
    TResult Function(ULexUserTypeXrpcProcedure value)? xrpcProcedure,
    TResult Function(ULexUserTypeXrpcSubscription value)? xrpcSubscription,
    TResult Function(ULexUserTypeBlob value)? blob,
    TResult Function(ULexUserTypeArray value)? array,
    TResult Function(ULexUserTypeToken value)? token,
    TResult Function(ULexUserTypeObject value)? object,
    TResult Function(ULexUserTypeBoolean value)? boolean,
    TResult Function(ULexUserTypeInteger value)? integer,
    TResult Function(ULexUserTypeString value)? string,
    TResult Function(ULexUserTypeBytes value)? bytes,
    TResult Function(ULexUserTypeCidLink value)? cidLink,
    TResult Function(ULexUserTypeUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (xrpcProcedure != null) {
      return xrpcProcedure(this);
    }
    return orElse();
  }
}

abstract class ULexUserTypeXrpcProcedure extends LexUserType {
  const factory ULexUserTypeXrpcProcedure(
      {required final LexXrpcProcedure data}) = _$ULexUserTypeXrpcProcedureImpl;
  const ULexUserTypeXrpcProcedure._() : super._();

  @override
  LexXrpcProcedure get data;

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ULexUserTypeXrpcProcedureImplCopyWith<_$ULexUserTypeXrpcProcedureImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ULexUserTypeXrpcSubscriptionImplCopyWith<$Res> {
  factory _$$ULexUserTypeXrpcSubscriptionImplCopyWith(
          _$ULexUserTypeXrpcSubscriptionImpl value,
          $Res Function(_$ULexUserTypeXrpcSubscriptionImpl) then) =
      __$$ULexUserTypeXrpcSubscriptionImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LexXrpcSubscription data});

  $LexXrpcSubscriptionCopyWith<$Res> get data;
}

/// @nodoc
class __$$ULexUserTypeXrpcSubscriptionImplCopyWithImpl<$Res>
    extends _$LexUserTypeCopyWithImpl<$Res, _$ULexUserTypeXrpcSubscriptionImpl>
    implements _$$ULexUserTypeXrpcSubscriptionImplCopyWith<$Res> {
  __$$ULexUserTypeXrpcSubscriptionImplCopyWithImpl(
      _$ULexUserTypeXrpcSubscriptionImpl _value,
      $Res Function(_$ULexUserTypeXrpcSubscriptionImpl) _then)
      : super(_value, _then);

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$ULexUserTypeXrpcSubscriptionImpl(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as LexXrpcSubscription,
    ));
  }

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LexXrpcSubscriptionCopyWith<$Res> get data {
    return $LexXrpcSubscriptionCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc

class _$ULexUserTypeXrpcSubscriptionImpl extends ULexUserTypeXrpcSubscription {
  const _$ULexUserTypeXrpcSubscriptionImpl({required this.data}) : super._();

  @override
  final LexXrpcSubscription data;

  @override
  String toString() {
    return 'LexUserType.xrpcSubscription(data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ULexUserTypeXrpcSubscriptionImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ULexUserTypeXrpcSubscriptionImplCopyWith<
          _$ULexUserTypeXrpcSubscriptionImpl>
      get copyWith => __$$ULexUserTypeXrpcSubscriptionImplCopyWithImpl<
          _$ULexUserTypeXrpcSubscriptionImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LexRecord data) record,
    required TResult Function(LexXrpcQuery data) xrpcQuery,
    required TResult Function(LexXrpcProcedure data) xrpcProcedure,
    required TResult Function(LexXrpcSubscription data) xrpcSubscription,
    required TResult Function(LexBlob data) blob,
    required TResult Function(LexArray data) array,
    required TResult Function(LexToken data) token,
    required TResult Function(LexObject data) object,
    required TResult Function(LexBoolean data) boolean,
    required TResult Function(LexInteger data) integer,
    required TResult Function(LexString data) string,
    required TResult Function(LexBytes data) bytes,
    required TResult Function(LexCidLink data) cidLink,
    required TResult Function(LexUnknown data) unknown,
  }) {
    return xrpcSubscription(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LexRecord data)? record,
    TResult? Function(LexXrpcQuery data)? xrpcQuery,
    TResult? Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult? Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult? Function(LexBlob data)? blob,
    TResult? Function(LexArray data)? array,
    TResult? Function(LexToken data)? token,
    TResult? Function(LexObject data)? object,
    TResult? Function(LexBoolean data)? boolean,
    TResult? Function(LexInteger data)? integer,
    TResult? Function(LexString data)? string,
    TResult? Function(LexBytes data)? bytes,
    TResult? Function(LexCidLink data)? cidLink,
    TResult? Function(LexUnknown data)? unknown,
  }) {
    return xrpcSubscription?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LexRecord data)? record,
    TResult Function(LexXrpcQuery data)? xrpcQuery,
    TResult Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult Function(LexBlob data)? blob,
    TResult Function(LexArray data)? array,
    TResult Function(LexToken data)? token,
    TResult Function(LexObject data)? object,
    TResult Function(LexBoolean data)? boolean,
    TResult Function(LexInteger data)? integer,
    TResult Function(LexString data)? string,
    TResult Function(LexBytes data)? bytes,
    TResult Function(LexCidLink data)? cidLink,
    TResult Function(LexUnknown data)? unknown,
    required TResult orElse(),
  }) {
    if (xrpcSubscription != null) {
      return xrpcSubscription(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ULexUserTypeRecord value) record,
    required TResult Function(ULexUserTypeXrpcQuery value) xrpcQuery,
    required TResult Function(ULexUserTypeXrpcProcedure value) xrpcProcedure,
    required TResult Function(ULexUserTypeXrpcSubscription value)
        xrpcSubscription,
    required TResult Function(ULexUserTypeBlob value) blob,
    required TResult Function(ULexUserTypeArray value) array,
    required TResult Function(ULexUserTypeToken value) token,
    required TResult Function(ULexUserTypeObject value) object,
    required TResult Function(ULexUserTypeBoolean value) boolean,
    required TResult Function(ULexUserTypeInteger value) integer,
    required TResult Function(ULexUserTypeString value) string,
    required TResult Function(ULexUserTypeBytes value) bytes,
    required TResult Function(ULexUserTypeCidLink value) cidLink,
    required TResult Function(ULexUserTypeUnknown value) unknown,
  }) {
    return xrpcSubscription(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ULexUserTypeRecord value)? record,
    TResult? Function(ULexUserTypeXrpcQuery value)? xrpcQuery,
    TResult? Function(ULexUserTypeXrpcProcedure value)? xrpcProcedure,
    TResult? Function(ULexUserTypeXrpcSubscription value)? xrpcSubscription,
    TResult? Function(ULexUserTypeBlob value)? blob,
    TResult? Function(ULexUserTypeArray value)? array,
    TResult? Function(ULexUserTypeToken value)? token,
    TResult? Function(ULexUserTypeObject value)? object,
    TResult? Function(ULexUserTypeBoolean value)? boolean,
    TResult? Function(ULexUserTypeInteger value)? integer,
    TResult? Function(ULexUserTypeString value)? string,
    TResult? Function(ULexUserTypeBytes value)? bytes,
    TResult? Function(ULexUserTypeCidLink value)? cidLink,
    TResult? Function(ULexUserTypeUnknown value)? unknown,
  }) {
    return xrpcSubscription?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ULexUserTypeRecord value)? record,
    TResult Function(ULexUserTypeXrpcQuery value)? xrpcQuery,
    TResult Function(ULexUserTypeXrpcProcedure value)? xrpcProcedure,
    TResult Function(ULexUserTypeXrpcSubscription value)? xrpcSubscription,
    TResult Function(ULexUserTypeBlob value)? blob,
    TResult Function(ULexUserTypeArray value)? array,
    TResult Function(ULexUserTypeToken value)? token,
    TResult Function(ULexUserTypeObject value)? object,
    TResult Function(ULexUserTypeBoolean value)? boolean,
    TResult Function(ULexUserTypeInteger value)? integer,
    TResult Function(ULexUserTypeString value)? string,
    TResult Function(ULexUserTypeBytes value)? bytes,
    TResult Function(ULexUserTypeCidLink value)? cidLink,
    TResult Function(ULexUserTypeUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (xrpcSubscription != null) {
      return xrpcSubscription(this);
    }
    return orElse();
  }
}

abstract class ULexUserTypeXrpcSubscription extends LexUserType {
  const factory ULexUserTypeXrpcSubscription(
          {required final LexXrpcSubscription data}) =
      _$ULexUserTypeXrpcSubscriptionImpl;
  const ULexUserTypeXrpcSubscription._() : super._();

  @override
  LexXrpcSubscription get data;

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ULexUserTypeXrpcSubscriptionImplCopyWith<
          _$ULexUserTypeXrpcSubscriptionImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ULexUserTypeBlobImplCopyWith<$Res> {
  factory _$$ULexUserTypeBlobImplCopyWith(_$ULexUserTypeBlobImpl value,
          $Res Function(_$ULexUserTypeBlobImpl) then) =
      __$$ULexUserTypeBlobImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LexBlob data});

  $LexBlobCopyWith<$Res> get data;
}

/// @nodoc
class __$$ULexUserTypeBlobImplCopyWithImpl<$Res>
    extends _$LexUserTypeCopyWithImpl<$Res, _$ULexUserTypeBlobImpl>
    implements _$$ULexUserTypeBlobImplCopyWith<$Res> {
  __$$ULexUserTypeBlobImplCopyWithImpl(_$ULexUserTypeBlobImpl _value,
      $Res Function(_$ULexUserTypeBlobImpl) _then)
      : super(_value, _then);

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$ULexUserTypeBlobImpl(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as LexBlob,
    ));
  }

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LexBlobCopyWith<$Res> get data {
    return $LexBlobCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc

class _$ULexUserTypeBlobImpl extends ULexUserTypeBlob {
  const _$ULexUserTypeBlobImpl({required this.data}) : super._();

  @override
  final LexBlob data;

  @override
  String toString() {
    return 'LexUserType.blob(data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ULexUserTypeBlobImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ULexUserTypeBlobImplCopyWith<_$ULexUserTypeBlobImpl> get copyWith =>
      __$$ULexUserTypeBlobImplCopyWithImpl<_$ULexUserTypeBlobImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LexRecord data) record,
    required TResult Function(LexXrpcQuery data) xrpcQuery,
    required TResult Function(LexXrpcProcedure data) xrpcProcedure,
    required TResult Function(LexXrpcSubscription data) xrpcSubscription,
    required TResult Function(LexBlob data) blob,
    required TResult Function(LexArray data) array,
    required TResult Function(LexToken data) token,
    required TResult Function(LexObject data) object,
    required TResult Function(LexBoolean data) boolean,
    required TResult Function(LexInteger data) integer,
    required TResult Function(LexString data) string,
    required TResult Function(LexBytes data) bytes,
    required TResult Function(LexCidLink data) cidLink,
    required TResult Function(LexUnknown data) unknown,
  }) {
    return blob(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LexRecord data)? record,
    TResult? Function(LexXrpcQuery data)? xrpcQuery,
    TResult? Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult? Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult? Function(LexBlob data)? blob,
    TResult? Function(LexArray data)? array,
    TResult? Function(LexToken data)? token,
    TResult? Function(LexObject data)? object,
    TResult? Function(LexBoolean data)? boolean,
    TResult? Function(LexInteger data)? integer,
    TResult? Function(LexString data)? string,
    TResult? Function(LexBytes data)? bytes,
    TResult? Function(LexCidLink data)? cidLink,
    TResult? Function(LexUnknown data)? unknown,
  }) {
    return blob?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LexRecord data)? record,
    TResult Function(LexXrpcQuery data)? xrpcQuery,
    TResult Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult Function(LexBlob data)? blob,
    TResult Function(LexArray data)? array,
    TResult Function(LexToken data)? token,
    TResult Function(LexObject data)? object,
    TResult Function(LexBoolean data)? boolean,
    TResult Function(LexInteger data)? integer,
    TResult Function(LexString data)? string,
    TResult Function(LexBytes data)? bytes,
    TResult Function(LexCidLink data)? cidLink,
    TResult Function(LexUnknown data)? unknown,
    required TResult orElse(),
  }) {
    if (blob != null) {
      return blob(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ULexUserTypeRecord value) record,
    required TResult Function(ULexUserTypeXrpcQuery value) xrpcQuery,
    required TResult Function(ULexUserTypeXrpcProcedure value) xrpcProcedure,
    required TResult Function(ULexUserTypeXrpcSubscription value)
        xrpcSubscription,
    required TResult Function(ULexUserTypeBlob value) blob,
    required TResult Function(ULexUserTypeArray value) array,
    required TResult Function(ULexUserTypeToken value) token,
    required TResult Function(ULexUserTypeObject value) object,
    required TResult Function(ULexUserTypeBoolean value) boolean,
    required TResult Function(ULexUserTypeInteger value) integer,
    required TResult Function(ULexUserTypeString value) string,
    required TResult Function(ULexUserTypeBytes value) bytes,
    required TResult Function(ULexUserTypeCidLink value) cidLink,
    required TResult Function(ULexUserTypeUnknown value) unknown,
  }) {
    return blob(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ULexUserTypeRecord value)? record,
    TResult? Function(ULexUserTypeXrpcQuery value)? xrpcQuery,
    TResult? Function(ULexUserTypeXrpcProcedure value)? xrpcProcedure,
    TResult? Function(ULexUserTypeXrpcSubscription value)? xrpcSubscription,
    TResult? Function(ULexUserTypeBlob value)? blob,
    TResult? Function(ULexUserTypeArray value)? array,
    TResult? Function(ULexUserTypeToken value)? token,
    TResult? Function(ULexUserTypeObject value)? object,
    TResult? Function(ULexUserTypeBoolean value)? boolean,
    TResult? Function(ULexUserTypeInteger value)? integer,
    TResult? Function(ULexUserTypeString value)? string,
    TResult? Function(ULexUserTypeBytes value)? bytes,
    TResult? Function(ULexUserTypeCidLink value)? cidLink,
    TResult? Function(ULexUserTypeUnknown value)? unknown,
  }) {
    return blob?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ULexUserTypeRecord value)? record,
    TResult Function(ULexUserTypeXrpcQuery value)? xrpcQuery,
    TResult Function(ULexUserTypeXrpcProcedure value)? xrpcProcedure,
    TResult Function(ULexUserTypeXrpcSubscription value)? xrpcSubscription,
    TResult Function(ULexUserTypeBlob value)? blob,
    TResult Function(ULexUserTypeArray value)? array,
    TResult Function(ULexUserTypeToken value)? token,
    TResult Function(ULexUserTypeObject value)? object,
    TResult Function(ULexUserTypeBoolean value)? boolean,
    TResult Function(ULexUserTypeInteger value)? integer,
    TResult Function(ULexUserTypeString value)? string,
    TResult Function(ULexUserTypeBytes value)? bytes,
    TResult Function(ULexUserTypeCidLink value)? cidLink,
    TResult Function(ULexUserTypeUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (blob != null) {
      return blob(this);
    }
    return orElse();
  }
}

abstract class ULexUserTypeBlob extends LexUserType {
  const factory ULexUserTypeBlob({required final LexBlob data}) =
      _$ULexUserTypeBlobImpl;
  const ULexUserTypeBlob._() : super._();

  @override
  LexBlob get data;

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ULexUserTypeBlobImplCopyWith<_$ULexUserTypeBlobImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ULexUserTypeArrayImplCopyWith<$Res> {
  factory _$$ULexUserTypeArrayImplCopyWith(_$ULexUserTypeArrayImpl value,
          $Res Function(_$ULexUserTypeArrayImpl) then) =
      __$$ULexUserTypeArrayImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LexArray data});

  $LexArrayCopyWith<$Res> get data;
}

/// @nodoc
class __$$ULexUserTypeArrayImplCopyWithImpl<$Res>
    extends _$LexUserTypeCopyWithImpl<$Res, _$ULexUserTypeArrayImpl>
    implements _$$ULexUserTypeArrayImplCopyWith<$Res> {
  __$$ULexUserTypeArrayImplCopyWithImpl(_$ULexUserTypeArrayImpl _value,
      $Res Function(_$ULexUserTypeArrayImpl) _then)
      : super(_value, _then);

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$ULexUserTypeArrayImpl(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as LexArray,
    ));
  }

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LexArrayCopyWith<$Res> get data {
    return $LexArrayCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc

class _$ULexUserTypeArrayImpl extends ULexUserTypeArray {
  const _$ULexUserTypeArrayImpl({required this.data}) : super._();

  @override
  final LexArray data;

  @override
  String toString() {
    return 'LexUserType.array(data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ULexUserTypeArrayImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ULexUserTypeArrayImplCopyWith<_$ULexUserTypeArrayImpl> get copyWith =>
      __$$ULexUserTypeArrayImplCopyWithImpl<_$ULexUserTypeArrayImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LexRecord data) record,
    required TResult Function(LexXrpcQuery data) xrpcQuery,
    required TResult Function(LexXrpcProcedure data) xrpcProcedure,
    required TResult Function(LexXrpcSubscription data) xrpcSubscription,
    required TResult Function(LexBlob data) blob,
    required TResult Function(LexArray data) array,
    required TResult Function(LexToken data) token,
    required TResult Function(LexObject data) object,
    required TResult Function(LexBoolean data) boolean,
    required TResult Function(LexInteger data) integer,
    required TResult Function(LexString data) string,
    required TResult Function(LexBytes data) bytes,
    required TResult Function(LexCidLink data) cidLink,
    required TResult Function(LexUnknown data) unknown,
  }) {
    return array(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LexRecord data)? record,
    TResult? Function(LexXrpcQuery data)? xrpcQuery,
    TResult? Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult? Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult? Function(LexBlob data)? blob,
    TResult? Function(LexArray data)? array,
    TResult? Function(LexToken data)? token,
    TResult? Function(LexObject data)? object,
    TResult? Function(LexBoolean data)? boolean,
    TResult? Function(LexInteger data)? integer,
    TResult? Function(LexString data)? string,
    TResult? Function(LexBytes data)? bytes,
    TResult? Function(LexCidLink data)? cidLink,
    TResult? Function(LexUnknown data)? unknown,
  }) {
    return array?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LexRecord data)? record,
    TResult Function(LexXrpcQuery data)? xrpcQuery,
    TResult Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult Function(LexBlob data)? blob,
    TResult Function(LexArray data)? array,
    TResult Function(LexToken data)? token,
    TResult Function(LexObject data)? object,
    TResult Function(LexBoolean data)? boolean,
    TResult Function(LexInteger data)? integer,
    TResult Function(LexString data)? string,
    TResult Function(LexBytes data)? bytes,
    TResult Function(LexCidLink data)? cidLink,
    TResult Function(LexUnknown data)? unknown,
    required TResult orElse(),
  }) {
    if (array != null) {
      return array(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ULexUserTypeRecord value) record,
    required TResult Function(ULexUserTypeXrpcQuery value) xrpcQuery,
    required TResult Function(ULexUserTypeXrpcProcedure value) xrpcProcedure,
    required TResult Function(ULexUserTypeXrpcSubscription value)
        xrpcSubscription,
    required TResult Function(ULexUserTypeBlob value) blob,
    required TResult Function(ULexUserTypeArray value) array,
    required TResult Function(ULexUserTypeToken value) token,
    required TResult Function(ULexUserTypeObject value) object,
    required TResult Function(ULexUserTypeBoolean value) boolean,
    required TResult Function(ULexUserTypeInteger value) integer,
    required TResult Function(ULexUserTypeString value) string,
    required TResult Function(ULexUserTypeBytes value) bytes,
    required TResult Function(ULexUserTypeCidLink value) cidLink,
    required TResult Function(ULexUserTypeUnknown value) unknown,
  }) {
    return array(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ULexUserTypeRecord value)? record,
    TResult? Function(ULexUserTypeXrpcQuery value)? xrpcQuery,
    TResult? Function(ULexUserTypeXrpcProcedure value)? xrpcProcedure,
    TResult? Function(ULexUserTypeXrpcSubscription value)? xrpcSubscription,
    TResult? Function(ULexUserTypeBlob value)? blob,
    TResult? Function(ULexUserTypeArray value)? array,
    TResult? Function(ULexUserTypeToken value)? token,
    TResult? Function(ULexUserTypeObject value)? object,
    TResult? Function(ULexUserTypeBoolean value)? boolean,
    TResult? Function(ULexUserTypeInteger value)? integer,
    TResult? Function(ULexUserTypeString value)? string,
    TResult? Function(ULexUserTypeBytes value)? bytes,
    TResult? Function(ULexUserTypeCidLink value)? cidLink,
    TResult? Function(ULexUserTypeUnknown value)? unknown,
  }) {
    return array?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ULexUserTypeRecord value)? record,
    TResult Function(ULexUserTypeXrpcQuery value)? xrpcQuery,
    TResult Function(ULexUserTypeXrpcProcedure value)? xrpcProcedure,
    TResult Function(ULexUserTypeXrpcSubscription value)? xrpcSubscription,
    TResult Function(ULexUserTypeBlob value)? blob,
    TResult Function(ULexUserTypeArray value)? array,
    TResult Function(ULexUserTypeToken value)? token,
    TResult Function(ULexUserTypeObject value)? object,
    TResult Function(ULexUserTypeBoolean value)? boolean,
    TResult Function(ULexUserTypeInteger value)? integer,
    TResult Function(ULexUserTypeString value)? string,
    TResult Function(ULexUserTypeBytes value)? bytes,
    TResult Function(ULexUserTypeCidLink value)? cidLink,
    TResult Function(ULexUserTypeUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (array != null) {
      return array(this);
    }
    return orElse();
  }
}

abstract class ULexUserTypeArray extends LexUserType {
  const factory ULexUserTypeArray({required final LexArray data}) =
      _$ULexUserTypeArrayImpl;
  const ULexUserTypeArray._() : super._();

  @override
  LexArray get data;

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ULexUserTypeArrayImplCopyWith<_$ULexUserTypeArrayImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ULexUserTypeTokenImplCopyWith<$Res> {
  factory _$$ULexUserTypeTokenImplCopyWith(_$ULexUserTypeTokenImpl value,
          $Res Function(_$ULexUserTypeTokenImpl) then) =
      __$$ULexUserTypeTokenImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LexToken data});

  $LexTokenCopyWith<$Res> get data;
}

/// @nodoc
class __$$ULexUserTypeTokenImplCopyWithImpl<$Res>
    extends _$LexUserTypeCopyWithImpl<$Res, _$ULexUserTypeTokenImpl>
    implements _$$ULexUserTypeTokenImplCopyWith<$Res> {
  __$$ULexUserTypeTokenImplCopyWithImpl(_$ULexUserTypeTokenImpl _value,
      $Res Function(_$ULexUserTypeTokenImpl) _then)
      : super(_value, _then);

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$ULexUserTypeTokenImpl(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as LexToken,
    ));
  }

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LexTokenCopyWith<$Res> get data {
    return $LexTokenCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc

class _$ULexUserTypeTokenImpl extends ULexUserTypeToken {
  const _$ULexUserTypeTokenImpl({required this.data}) : super._();

  @override
  final LexToken data;

  @override
  String toString() {
    return 'LexUserType.token(data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ULexUserTypeTokenImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ULexUserTypeTokenImplCopyWith<_$ULexUserTypeTokenImpl> get copyWith =>
      __$$ULexUserTypeTokenImplCopyWithImpl<_$ULexUserTypeTokenImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LexRecord data) record,
    required TResult Function(LexXrpcQuery data) xrpcQuery,
    required TResult Function(LexXrpcProcedure data) xrpcProcedure,
    required TResult Function(LexXrpcSubscription data) xrpcSubscription,
    required TResult Function(LexBlob data) blob,
    required TResult Function(LexArray data) array,
    required TResult Function(LexToken data) token,
    required TResult Function(LexObject data) object,
    required TResult Function(LexBoolean data) boolean,
    required TResult Function(LexInteger data) integer,
    required TResult Function(LexString data) string,
    required TResult Function(LexBytes data) bytes,
    required TResult Function(LexCidLink data) cidLink,
    required TResult Function(LexUnknown data) unknown,
  }) {
    return token(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LexRecord data)? record,
    TResult? Function(LexXrpcQuery data)? xrpcQuery,
    TResult? Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult? Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult? Function(LexBlob data)? blob,
    TResult? Function(LexArray data)? array,
    TResult? Function(LexToken data)? token,
    TResult? Function(LexObject data)? object,
    TResult? Function(LexBoolean data)? boolean,
    TResult? Function(LexInteger data)? integer,
    TResult? Function(LexString data)? string,
    TResult? Function(LexBytes data)? bytes,
    TResult? Function(LexCidLink data)? cidLink,
    TResult? Function(LexUnknown data)? unknown,
  }) {
    return token?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LexRecord data)? record,
    TResult Function(LexXrpcQuery data)? xrpcQuery,
    TResult Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult Function(LexBlob data)? blob,
    TResult Function(LexArray data)? array,
    TResult Function(LexToken data)? token,
    TResult Function(LexObject data)? object,
    TResult Function(LexBoolean data)? boolean,
    TResult Function(LexInteger data)? integer,
    TResult Function(LexString data)? string,
    TResult Function(LexBytes data)? bytes,
    TResult Function(LexCidLink data)? cidLink,
    TResult Function(LexUnknown data)? unknown,
    required TResult orElse(),
  }) {
    if (token != null) {
      return token(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ULexUserTypeRecord value) record,
    required TResult Function(ULexUserTypeXrpcQuery value) xrpcQuery,
    required TResult Function(ULexUserTypeXrpcProcedure value) xrpcProcedure,
    required TResult Function(ULexUserTypeXrpcSubscription value)
        xrpcSubscription,
    required TResult Function(ULexUserTypeBlob value) blob,
    required TResult Function(ULexUserTypeArray value) array,
    required TResult Function(ULexUserTypeToken value) token,
    required TResult Function(ULexUserTypeObject value) object,
    required TResult Function(ULexUserTypeBoolean value) boolean,
    required TResult Function(ULexUserTypeInteger value) integer,
    required TResult Function(ULexUserTypeString value) string,
    required TResult Function(ULexUserTypeBytes value) bytes,
    required TResult Function(ULexUserTypeCidLink value) cidLink,
    required TResult Function(ULexUserTypeUnknown value) unknown,
  }) {
    return token(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ULexUserTypeRecord value)? record,
    TResult? Function(ULexUserTypeXrpcQuery value)? xrpcQuery,
    TResult? Function(ULexUserTypeXrpcProcedure value)? xrpcProcedure,
    TResult? Function(ULexUserTypeXrpcSubscription value)? xrpcSubscription,
    TResult? Function(ULexUserTypeBlob value)? blob,
    TResult? Function(ULexUserTypeArray value)? array,
    TResult? Function(ULexUserTypeToken value)? token,
    TResult? Function(ULexUserTypeObject value)? object,
    TResult? Function(ULexUserTypeBoolean value)? boolean,
    TResult? Function(ULexUserTypeInteger value)? integer,
    TResult? Function(ULexUserTypeString value)? string,
    TResult? Function(ULexUserTypeBytes value)? bytes,
    TResult? Function(ULexUserTypeCidLink value)? cidLink,
    TResult? Function(ULexUserTypeUnknown value)? unknown,
  }) {
    return token?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ULexUserTypeRecord value)? record,
    TResult Function(ULexUserTypeXrpcQuery value)? xrpcQuery,
    TResult Function(ULexUserTypeXrpcProcedure value)? xrpcProcedure,
    TResult Function(ULexUserTypeXrpcSubscription value)? xrpcSubscription,
    TResult Function(ULexUserTypeBlob value)? blob,
    TResult Function(ULexUserTypeArray value)? array,
    TResult Function(ULexUserTypeToken value)? token,
    TResult Function(ULexUserTypeObject value)? object,
    TResult Function(ULexUserTypeBoolean value)? boolean,
    TResult Function(ULexUserTypeInteger value)? integer,
    TResult Function(ULexUserTypeString value)? string,
    TResult Function(ULexUserTypeBytes value)? bytes,
    TResult Function(ULexUserTypeCidLink value)? cidLink,
    TResult Function(ULexUserTypeUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (token != null) {
      return token(this);
    }
    return orElse();
  }
}

abstract class ULexUserTypeToken extends LexUserType {
  const factory ULexUserTypeToken({required final LexToken data}) =
      _$ULexUserTypeTokenImpl;
  const ULexUserTypeToken._() : super._();

  @override
  LexToken get data;

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ULexUserTypeTokenImplCopyWith<_$ULexUserTypeTokenImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ULexUserTypeObjectImplCopyWith<$Res> {
  factory _$$ULexUserTypeObjectImplCopyWith(_$ULexUserTypeObjectImpl value,
          $Res Function(_$ULexUserTypeObjectImpl) then) =
      __$$ULexUserTypeObjectImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LexObject data});

  $LexObjectCopyWith<$Res> get data;
}

/// @nodoc
class __$$ULexUserTypeObjectImplCopyWithImpl<$Res>
    extends _$LexUserTypeCopyWithImpl<$Res, _$ULexUserTypeObjectImpl>
    implements _$$ULexUserTypeObjectImplCopyWith<$Res> {
  __$$ULexUserTypeObjectImplCopyWithImpl(_$ULexUserTypeObjectImpl _value,
      $Res Function(_$ULexUserTypeObjectImpl) _then)
      : super(_value, _then);

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$ULexUserTypeObjectImpl(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as LexObject,
    ));
  }

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LexObjectCopyWith<$Res> get data {
    return $LexObjectCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc

class _$ULexUserTypeObjectImpl extends ULexUserTypeObject {
  const _$ULexUserTypeObjectImpl({required this.data}) : super._();

  @override
  final LexObject data;

  @override
  String toString() {
    return 'LexUserType.object(data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ULexUserTypeObjectImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ULexUserTypeObjectImplCopyWith<_$ULexUserTypeObjectImpl> get copyWith =>
      __$$ULexUserTypeObjectImplCopyWithImpl<_$ULexUserTypeObjectImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LexRecord data) record,
    required TResult Function(LexXrpcQuery data) xrpcQuery,
    required TResult Function(LexXrpcProcedure data) xrpcProcedure,
    required TResult Function(LexXrpcSubscription data) xrpcSubscription,
    required TResult Function(LexBlob data) blob,
    required TResult Function(LexArray data) array,
    required TResult Function(LexToken data) token,
    required TResult Function(LexObject data) object,
    required TResult Function(LexBoolean data) boolean,
    required TResult Function(LexInteger data) integer,
    required TResult Function(LexString data) string,
    required TResult Function(LexBytes data) bytes,
    required TResult Function(LexCidLink data) cidLink,
    required TResult Function(LexUnknown data) unknown,
  }) {
    return object(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LexRecord data)? record,
    TResult? Function(LexXrpcQuery data)? xrpcQuery,
    TResult? Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult? Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult? Function(LexBlob data)? blob,
    TResult? Function(LexArray data)? array,
    TResult? Function(LexToken data)? token,
    TResult? Function(LexObject data)? object,
    TResult? Function(LexBoolean data)? boolean,
    TResult? Function(LexInteger data)? integer,
    TResult? Function(LexString data)? string,
    TResult? Function(LexBytes data)? bytes,
    TResult? Function(LexCidLink data)? cidLink,
    TResult? Function(LexUnknown data)? unknown,
  }) {
    return object?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LexRecord data)? record,
    TResult Function(LexXrpcQuery data)? xrpcQuery,
    TResult Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult Function(LexBlob data)? blob,
    TResult Function(LexArray data)? array,
    TResult Function(LexToken data)? token,
    TResult Function(LexObject data)? object,
    TResult Function(LexBoolean data)? boolean,
    TResult Function(LexInteger data)? integer,
    TResult Function(LexString data)? string,
    TResult Function(LexBytes data)? bytes,
    TResult Function(LexCidLink data)? cidLink,
    TResult Function(LexUnknown data)? unknown,
    required TResult orElse(),
  }) {
    if (object != null) {
      return object(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ULexUserTypeRecord value) record,
    required TResult Function(ULexUserTypeXrpcQuery value) xrpcQuery,
    required TResult Function(ULexUserTypeXrpcProcedure value) xrpcProcedure,
    required TResult Function(ULexUserTypeXrpcSubscription value)
        xrpcSubscription,
    required TResult Function(ULexUserTypeBlob value) blob,
    required TResult Function(ULexUserTypeArray value) array,
    required TResult Function(ULexUserTypeToken value) token,
    required TResult Function(ULexUserTypeObject value) object,
    required TResult Function(ULexUserTypeBoolean value) boolean,
    required TResult Function(ULexUserTypeInteger value) integer,
    required TResult Function(ULexUserTypeString value) string,
    required TResult Function(ULexUserTypeBytes value) bytes,
    required TResult Function(ULexUserTypeCidLink value) cidLink,
    required TResult Function(ULexUserTypeUnknown value) unknown,
  }) {
    return object(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ULexUserTypeRecord value)? record,
    TResult? Function(ULexUserTypeXrpcQuery value)? xrpcQuery,
    TResult? Function(ULexUserTypeXrpcProcedure value)? xrpcProcedure,
    TResult? Function(ULexUserTypeXrpcSubscription value)? xrpcSubscription,
    TResult? Function(ULexUserTypeBlob value)? blob,
    TResult? Function(ULexUserTypeArray value)? array,
    TResult? Function(ULexUserTypeToken value)? token,
    TResult? Function(ULexUserTypeObject value)? object,
    TResult? Function(ULexUserTypeBoolean value)? boolean,
    TResult? Function(ULexUserTypeInteger value)? integer,
    TResult? Function(ULexUserTypeString value)? string,
    TResult? Function(ULexUserTypeBytes value)? bytes,
    TResult? Function(ULexUserTypeCidLink value)? cidLink,
    TResult? Function(ULexUserTypeUnknown value)? unknown,
  }) {
    return object?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ULexUserTypeRecord value)? record,
    TResult Function(ULexUserTypeXrpcQuery value)? xrpcQuery,
    TResult Function(ULexUserTypeXrpcProcedure value)? xrpcProcedure,
    TResult Function(ULexUserTypeXrpcSubscription value)? xrpcSubscription,
    TResult Function(ULexUserTypeBlob value)? blob,
    TResult Function(ULexUserTypeArray value)? array,
    TResult Function(ULexUserTypeToken value)? token,
    TResult Function(ULexUserTypeObject value)? object,
    TResult Function(ULexUserTypeBoolean value)? boolean,
    TResult Function(ULexUserTypeInteger value)? integer,
    TResult Function(ULexUserTypeString value)? string,
    TResult Function(ULexUserTypeBytes value)? bytes,
    TResult Function(ULexUserTypeCidLink value)? cidLink,
    TResult Function(ULexUserTypeUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (object != null) {
      return object(this);
    }
    return orElse();
  }
}

abstract class ULexUserTypeObject extends LexUserType {
  const factory ULexUserTypeObject({required final LexObject data}) =
      _$ULexUserTypeObjectImpl;
  const ULexUserTypeObject._() : super._();

  @override
  LexObject get data;

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ULexUserTypeObjectImplCopyWith<_$ULexUserTypeObjectImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ULexUserTypeBooleanImplCopyWith<$Res> {
  factory _$$ULexUserTypeBooleanImplCopyWith(_$ULexUserTypeBooleanImpl value,
          $Res Function(_$ULexUserTypeBooleanImpl) then) =
      __$$ULexUserTypeBooleanImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LexBoolean data});

  $LexBooleanCopyWith<$Res> get data;
}

/// @nodoc
class __$$ULexUserTypeBooleanImplCopyWithImpl<$Res>
    extends _$LexUserTypeCopyWithImpl<$Res, _$ULexUserTypeBooleanImpl>
    implements _$$ULexUserTypeBooleanImplCopyWith<$Res> {
  __$$ULexUserTypeBooleanImplCopyWithImpl(_$ULexUserTypeBooleanImpl _value,
      $Res Function(_$ULexUserTypeBooleanImpl) _then)
      : super(_value, _then);

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$ULexUserTypeBooleanImpl(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as LexBoolean,
    ));
  }

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LexBooleanCopyWith<$Res> get data {
    return $LexBooleanCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc

class _$ULexUserTypeBooleanImpl extends ULexUserTypeBoolean {
  const _$ULexUserTypeBooleanImpl({required this.data}) : super._();

  @override
  final LexBoolean data;

  @override
  String toString() {
    return 'LexUserType.boolean(data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ULexUserTypeBooleanImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ULexUserTypeBooleanImplCopyWith<_$ULexUserTypeBooleanImpl> get copyWith =>
      __$$ULexUserTypeBooleanImplCopyWithImpl<_$ULexUserTypeBooleanImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LexRecord data) record,
    required TResult Function(LexXrpcQuery data) xrpcQuery,
    required TResult Function(LexXrpcProcedure data) xrpcProcedure,
    required TResult Function(LexXrpcSubscription data) xrpcSubscription,
    required TResult Function(LexBlob data) blob,
    required TResult Function(LexArray data) array,
    required TResult Function(LexToken data) token,
    required TResult Function(LexObject data) object,
    required TResult Function(LexBoolean data) boolean,
    required TResult Function(LexInteger data) integer,
    required TResult Function(LexString data) string,
    required TResult Function(LexBytes data) bytes,
    required TResult Function(LexCidLink data) cidLink,
    required TResult Function(LexUnknown data) unknown,
  }) {
    return boolean(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LexRecord data)? record,
    TResult? Function(LexXrpcQuery data)? xrpcQuery,
    TResult? Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult? Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult? Function(LexBlob data)? blob,
    TResult? Function(LexArray data)? array,
    TResult? Function(LexToken data)? token,
    TResult? Function(LexObject data)? object,
    TResult? Function(LexBoolean data)? boolean,
    TResult? Function(LexInteger data)? integer,
    TResult? Function(LexString data)? string,
    TResult? Function(LexBytes data)? bytes,
    TResult? Function(LexCidLink data)? cidLink,
    TResult? Function(LexUnknown data)? unknown,
  }) {
    return boolean?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LexRecord data)? record,
    TResult Function(LexXrpcQuery data)? xrpcQuery,
    TResult Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult Function(LexBlob data)? blob,
    TResult Function(LexArray data)? array,
    TResult Function(LexToken data)? token,
    TResult Function(LexObject data)? object,
    TResult Function(LexBoolean data)? boolean,
    TResult Function(LexInteger data)? integer,
    TResult Function(LexString data)? string,
    TResult Function(LexBytes data)? bytes,
    TResult Function(LexCidLink data)? cidLink,
    TResult Function(LexUnknown data)? unknown,
    required TResult orElse(),
  }) {
    if (boolean != null) {
      return boolean(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ULexUserTypeRecord value) record,
    required TResult Function(ULexUserTypeXrpcQuery value) xrpcQuery,
    required TResult Function(ULexUserTypeXrpcProcedure value) xrpcProcedure,
    required TResult Function(ULexUserTypeXrpcSubscription value)
        xrpcSubscription,
    required TResult Function(ULexUserTypeBlob value) blob,
    required TResult Function(ULexUserTypeArray value) array,
    required TResult Function(ULexUserTypeToken value) token,
    required TResult Function(ULexUserTypeObject value) object,
    required TResult Function(ULexUserTypeBoolean value) boolean,
    required TResult Function(ULexUserTypeInteger value) integer,
    required TResult Function(ULexUserTypeString value) string,
    required TResult Function(ULexUserTypeBytes value) bytes,
    required TResult Function(ULexUserTypeCidLink value) cidLink,
    required TResult Function(ULexUserTypeUnknown value) unknown,
  }) {
    return boolean(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ULexUserTypeRecord value)? record,
    TResult? Function(ULexUserTypeXrpcQuery value)? xrpcQuery,
    TResult? Function(ULexUserTypeXrpcProcedure value)? xrpcProcedure,
    TResult? Function(ULexUserTypeXrpcSubscription value)? xrpcSubscription,
    TResult? Function(ULexUserTypeBlob value)? blob,
    TResult? Function(ULexUserTypeArray value)? array,
    TResult? Function(ULexUserTypeToken value)? token,
    TResult? Function(ULexUserTypeObject value)? object,
    TResult? Function(ULexUserTypeBoolean value)? boolean,
    TResult? Function(ULexUserTypeInteger value)? integer,
    TResult? Function(ULexUserTypeString value)? string,
    TResult? Function(ULexUserTypeBytes value)? bytes,
    TResult? Function(ULexUserTypeCidLink value)? cidLink,
    TResult? Function(ULexUserTypeUnknown value)? unknown,
  }) {
    return boolean?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ULexUserTypeRecord value)? record,
    TResult Function(ULexUserTypeXrpcQuery value)? xrpcQuery,
    TResult Function(ULexUserTypeXrpcProcedure value)? xrpcProcedure,
    TResult Function(ULexUserTypeXrpcSubscription value)? xrpcSubscription,
    TResult Function(ULexUserTypeBlob value)? blob,
    TResult Function(ULexUserTypeArray value)? array,
    TResult Function(ULexUserTypeToken value)? token,
    TResult Function(ULexUserTypeObject value)? object,
    TResult Function(ULexUserTypeBoolean value)? boolean,
    TResult Function(ULexUserTypeInteger value)? integer,
    TResult Function(ULexUserTypeString value)? string,
    TResult Function(ULexUserTypeBytes value)? bytes,
    TResult Function(ULexUserTypeCidLink value)? cidLink,
    TResult Function(ULexUserTypeUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (boolean != null) {
      return boolean(this);
    }
    return orElse();
  }
}

abstract class ULexUserTypeBoolean extends LexUserType {
  const factory ULexUserTypeBoolean({required final LexBoolean data}) =
      _$ULexUserTypeBooleanImpl;
  const ULexUserTypeBoolean._() : super._();

  @override
  LexBoolean get data;

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ULexUserTypeBooleanImplCopyWith<_$ULexUserTypeBooleanImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ULexUserTypeIntegerImplCopyWith<$Res> {
  factory _$$ULexUserTypeIntegerImplCopyWith(_$ULexUserTypeIntegerImpl value,
          $Res Function(_$ULexUserTypeIntegerImpl) then) =
      __$$ULexUserTypeIntegerImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LexInteger data});

  $LexIntegerCopyWith<$Res> get data;
}

/// @nodoc
class __$$ULexUserTypeIntegerImplCopyWithImpl<$Res>
    extends _$LexUserTypeCopyWithImpl<$Res, _$ULexUserTypeIntegerImpl>
    implements _$$ULexUserTypeIntegerImplCopyWith<$Res> {
  __$$ULexUserTypeIntegerImplCopyWithImpl(_$ULexUserTypeIntegerImpl _value,
      $Res Function(_$ULexUserTypeIntegerImpl) _then)
      : super(_value, _then);

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$ULexUserTypeIntegerImpl(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as LexInteger,
    ));
  }

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LexIntegerCopyWith<$Res> get data {
    return $LexIntegerCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc

class _$ULexUserTypeIntegerImpl extends ULexUserTypeInteger {
  const _$ULexUserTypeIntegerImpl({required this.data}) : super._();

  @override
  final LexInteger data;

  @override
  String toString() {
    return 'LexUserType.integer(data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ULexUserTypeIntegerImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ULexUserTypeIntegerImplCopyWith<_$ULexUserTypeIntegerImpl> get copyWith =>
      __$$ULexUserTypeIntegerImplCopyWithImpl<_$ULexUserTypeIntegerImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LexRecord data) record,
    required TResult Function(LexXrpcQuery data) xrpcQuery,
    required TResult Function(LexXrpcProcedure data) xrpcProcedure,
    required TResult Function(LexXrpcSubscription data) xrpcSubscription,
    required TResult Function(LexBlob data) blob,
    required TResult Function(LexArray data) array,
    required TResult Function(LexToken data) token,
    required TResult Function(LexObject data) object,
    required TResult Function(LexBoolean data) boolean,
    required TResult Function(LexInteger data) integer,
    required TResult Function(LexString data) string,
    required TResult Function(LexBytes data) bytes,
    required TResult Function(LexCidLink data) cidLink,
    required TResult Function(LexUnknown data) unknown,
  }) {
    return integer(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LexRecord data)? record,
    TResult? Function(LexXrpcQuery data)? xrpcQuery,
    TResult? Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult? Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult? Function(LexBlob data)? blob,
    TResult? Function(LexArray data)? array,
    TResult? Function(LexToken data)? token,
    TResult? Function(LexObject data)? object,
    TResult? Function(LexBoolean data)? boolean,
    TResult? Function(LexInteger data)? integer,
    TResult? Function(LexString data)? string,
    TResult? Function(LexBytes data)? bytes,
    TResult? Function(LexCidLink data)? cidLink,
    TResult? Function(LexUnknown data)? unknown,
  }) {
    return integer?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LexRecord data)? record,
    TResult Function(LexXrpcQuery data)? xrpcQuery,
    TResult Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult Function(LexBlob data)? blob,
    TResult Function(LexArray data)? array,
    TResult Function(LexToken data)? token,
    TResult Function(LexObject data)? object,
    TResult Function(LexBoolean data)? boolean,
    TResult Function(LexInteger data)? integer,
    TResult Function(LexString data)? string,
    TResult Function(LexBytes data)? bytes,
    TResult Function(LexCidLink data)? cidLink,
    TResult Function(LexUnknown data)? unknown,
    required TResult orElse(),
  }) {
    if (integer != null) {
      return integer(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ULexUserTypeRecord value) record,
    required TResult Function(ULexUserTypeXrpcQuery value) xrpcQuery,
    required TResult Function(ULexUserTypeXrpcProcedure value) xrpcProcedure,
    required TResult Function(ULexUserTypeXrpcSubscription value)
        xrpcSubscription,
    required TResult Function(ULexUserTypeBlob value) blob,
    required TResult Function(ULexUserTypeArray value) array,
    required TResult Function(ULexUserTypeToken value) token,
    required TResult Function(ULexUserTypeObject value) object,
    required TResult Function(ULexUserTypeBoolean value) boolean,
    required TResult Function(ULexUserTypeInteger value) integer,
    required TResult Function(ULexUserTypeString value) string,
    required TResult Function(ULexUserTypeBytes value) bytes,
    required TResult Function(ULexUserTypeCidLink value) cidLink,
    required TResult Function(ULexUserTypeUnknown value) unknown,
  }) {
    return integer(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ULexUserTypeRecord value)? record,
    TResult? Function(ULexUserTypeXrpcQuery value)? xrpcQuery,
    TResult? Function(ULexUserTypeXrpcProcedure value)? xrpcProcedure,
    TResult? Function(ULexUserTypeXrpcSubscription value)? xrpcSubscription,
    TResult? Function(ULexUserTypeBlob value)? blob,
    TResult? Function(ULexUserTypeArray value)? array,
    TResult? Function(ULexUserTypeToken value)? token,
    TResult? Function(ULexUserTypeObject value)? object,
    TResult? Function(ULexUserTypeBoolean value)? boolean,
    TResult? Function(ULexUserTypeInteger value)? integer,
    TResult? Function(ULexUserTypeString value)? string,
    TResult? Function(ULexUserTypeBytes value)? bytes,
    TResult? Function(ULexUserTypeCidLink value)? cidLink,
    TResult? Function(ULexUserTypeUnknown value)? unknown,
  }) {
    return integer?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ULexUserTypeRecord value)? record,
    TResult Function(ULexUserTypeXrpcQuery value)? xrpcQuery,
    TResult Function(ULexUserTypeXrpcProcedure value)? xrpcProcedure,
    TResult Function(ULexUserTypeXrpcSubscription value)? xrpcSubscription,
    TResult Function(ULexUserTypeBlob value)? blob,
    TResult Function(ULexUserTypeArray value)? array,
    TResult Function(ULexUserTypeToken value)? token,
    TResult Function(ULexUserTypeObject value)? object,
    TResult Function(ULexUserTypeBoolean value)? boolean,
    TResult Function(ULexUserTypeInteger value)? integer,
    TResult Function(ULexUserTypeString value)? string,
    TResult Function(ULexUserTypeBytes value)? bytes,
    TResult Function(ULexUserTypeCidLink value)? cidLink,
    TResult Function(ULexUserTypeUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (integer != null) {
      return integer(this);
    }
    return orElse();
  }
}

abstract class ULexUserTypeInteger extends LexUserType {
  const factory ULexUserTypeInteger({required final LexInteger data}) =
      _$ULexUserTypeIntegerImpl;
  const ULexUserTypeInteger._() : super._();

  @override
  LexInteger get data;

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ULexUserTypeIntegerImplCopyWith<_$ULexUserTypeIntegerImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ULexUserTypeStringImplCopyWith<$Res> {
  factory _$$ULexUserTypeStringImplCopyWith(_$ULexUserTypeStringImpl value,
          $Res Function(_$ULexUserTypeStringImpl) then) =
      __$$ULexUserTypeStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LexString data});

  $LexStringCopyWith<$Res> get data;
}

/// @nodoc
class __$$ULexUserTypeStringImplCopyWithImpl<$Res>
    extends _$LexUserTypeCopyWithImpl<$Res, _$ULexUserTypeStringImpl>
    implements _$$ULexUserTypeStringImplCopyWith<$Res> {
  __$$ULexUserTypeStringImplCopyWithImpl(_$ULexUserTypeStringImpl _value,
      $Res Function(_$ULexUserTypeStringImpl) _then)
      : super(_value, _then);

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$ULexUserTypeStringImpl(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as LexString,
    ));
  }

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LexStringCopyWith<$Res> get data {
    return $LexStringCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc

class _$ULexUserTypeStringImpl extends ULexUserTypeString {
  const _$ULexUserTypeStringImpl({required this.data}) : super._();

  @override
  final LexString data;

  @override
  String toString() {
    return 'LexUserType.string(data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ULexUserTypeStringImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ULexUserTypeStringImplCopyWith<_$ULexUserTypeStringImpl> get copyWith =>
      __$$ULexUserTypeStringImplCopyWithImpl<_$ULexUserTypeStringImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LexRecord data) record,
    required TResult Function(LexXrpcQuery data) xrpcQuery,
    required TResult Function(LexXrpcProcedure data) xrpcProcedure,
    required TResult Function(LexXrpcSubscription data) xrpcSubscription,
    required TResult Function(LexBlob data) blob,
    required TResult Function(LexArray data) array,
    required TResult Function(LexToken data) token,
    required TResult Function(LexObject data) object,
    required TResult Function(LexBoolean data) boolean,
    required TResult Function(LexInteger data) integer,
    required TResult Function(LexString data) string,
    required TResult Function(LexBytes data) bytes,
    required TResult Function(LexCidLink data) cidLink,
    required TResult Function(LexUnknown data) unknown,
  }) {
    return string(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LexRecord data)? record,
    TResult? Function(LexXrpcQuery data)? xrpcQuery,
    TResult? Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult? Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult? Function(LexBlob data)? blob,
    TResult? Function(LexArray data)? array,
    TResult? Function(LexToken data)? token,
    TResult? Function(LexObject data)? object,
    TResult? Function(LexBoolean data)? boolean,
    TResult? Function(LexInteger data)? integer,
    TResult? Function(LexString data)? string,
    TResult? Function(LexBytes data)? bytes,
    TResult? Function(LexCidLink data)? cidLink,
    TResult? Function(LexUnknown data)? unknown,
  }) {
    return string?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LexRecord data)? record,
    TResult Function(LexXrpcQuery data)? xrpcQuery,
    TResult Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult Function(LexBlob data)? blob,
    TResult Function(LexArray data)? array,
    TResult Function(LexToken data)? token,
    TResult Function(LexObject data)? object,
    TResult Function(LexBoolean data)? boolean,
    TResult Function(LexInteger data)? integer,
    TResult Function(LexString data)? string,
    TResult Function(LexBytes data)? bytes,
    TResult Function(LexCidLink data)? cidLink,
    TResult Function(LexUnknown data)? unknown,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ULexUserTypeRecord value) record,
    required TResult Function(ULexUserTypeXrpcQuery value) xrpcQuery,
    required TResult Function(ULexUserTypeXrpcProcedure value) xrpcProcedure,
    required TResult Function(ULexUserTypeXrpcSubscription value)
        xrpcSubscription,
    required TResult Function(ULexUserTypeBlob value) blob,
    required TResult Function(ULexUserTypeArray value) array,
    required TResult Function(ULexUserTypeToken value) token,
    required TResult Function(ULexUserTypeObject value) object,
    required TResult Function(ULexUserTypeBoolean value) boolean,
    required TResult Function(ULexUserTypeInteger value) integer,
    required TResult Function(ULexUserTypeString value) string,
    required TResult Function(ULexUserTypeBytes value) bytes,
    required TResult Function(ULexUserTypeCidLink value) cidLink,
    required TResult Function(ULexUserTypeUnknown value) unknown,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ULexUserTypeRecord value)? record,
    TResult? Function(ULexUserTypeXrpcQuery value)? xrpcQuery,
    TResult? Function(ULexUserTypeXrpcProcedure value)? xrpcProcedure,
    TResult? Function(ULexUserTypeXrpcSubscription value)? xrpcSubscription,
    TResult? Function(ULexUserTypeBlob value)? blob,
    TResult? Function(ULexUserTypeArray value)? array,
    TResult? Function(ULexUserTypeToken value)? token,
    TResult? Function(ULexUserTypeObject value)? object,
    TResult? Function(ULexUserTypeBoolean value)? boolean,
    TResult? Function(ULexUserTypeInteger value)? integer,
    TResult? Function(ULexUserTypeString value)? string,
    TResult? Function(ULexUserTypeBytes value)? bytes,
    TResult? Function(ULexUserTypeCidLink value)? cidLink,
    TResult? Function(ULexUserTypeUnknown value)? unknown,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ULexUserTypeRecord value)? record,
    TResult Function(ULexUserTypeXrpcQuery value)? xrpcQuery,
    TResult Function(ULexUserTypeXrpcProcedure value)? xrpcProcedure,
    TResult Function(ULexUserTypeXrpcSubscription value)? xrpcSubscription,
    TResult Function(ULexUserTypeBlob value)? blob,
    TResult Function(ULexUserTypeArray value)? array,
    TResult Function(ULexUserTypeToken value)? token,
    TResult Function(ULexUserTypeObject value)? object,
    TResult Function(ULexUserTypeBoolean value)? boolean,
    TResult Function(ULexUserTypeInteger value)? integer,
    TResult Function(ULexUserTypeString value)? string,
    TResult Function(ULexUserTypeBytes value)? bytes,
    TResult Function(ULexUserTypeCidLink value)? cidLink,
    TResult Function(ULexUserTypeUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }
}

abstract class ULexUserTypeString extends LexUserType {
  const factory ULexUserTypeString({required final LexString data}) =
      _$ULexUserTypeStringImpl;
  const ULexUserTypeString._() : super._();

  @override
  LexString get data;

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ULexUserTypeStringImplCopyWith<_$ULexUserTypeStringImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ULexUserTypeBytesImplCopyWith<$Res> {
  factory _$$ULexUserTypeBytesImplCopyWith(_$ULexUserTypeBytesImpl value,
          $Res Function(_$ULexUserTypeBytesImpl) then) =
      __$$ULexUserTypeBytesImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LexBytes data});

  $LexBytesCopyWith<$Res> get data;
}

/// @nodoc
class __$$ULexUserTypeBytesImplCopyWithImpl<$Res>
    extends _$LexUserTypeCopyWithImpl<$Res, _$ULexUserTypeBytesImpl>
    implements _$$ULexUserTypeBytesImplCopyWith<$Res> {
  __$$ULexUserTypeBytesImplCopyWithImpl(_$ULexUserTypeBytesImpl _value,
      $Res Function(_$ULexUserTypeBytesImpl) _then)
      : super(_value, _then);

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$ULexUserTypeBytesImpl(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as LexBytes,
    ));
  }

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LexBytesCopyWith<$Res> get data {
    return $LexBytesCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc

class _$ULexUserTypeBytesImpl extends ULexUserTypeBytes {
  const _$ULexUserTypeBytesImpl({required this.data}) : super._();

  @override
  final LexBytes data;

  @override
  String toString() {
    return 'LexUserType.bytes(data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ULexUserTypeBytesImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ULexUserTypeBytesImplCopyWith<_$ULexUserTypeBytesImpl> get copyWith =>
      __$$ULexUserTypeBytesImplCopyWithImpl<_$ULexUserTypeBytesImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LexRecord data) record,
    required TResult Function(LexXrpcQuery data) xrpcQuery,
    required TResult Function(LexXrpcProcedure data) xrpcProcedure,
    required TResult Function(LexXrpcSubscription data) xrpcSubscription,
    required TResult Function(LexBlob data) blob,
    required TResult Function(LexArray data) array,
    required TResult Function(LexToken data) token,
    required TResult Function(LexObject data) object,
    required TResult Function(LexBoolean data) boolean,
    required TResult Function(LexInteger data) integer,
    required TResult Function(LexString data) string,
    required TResult Function(LexBytes data) bytes,
    required TResult Function(LexCidLink data) cidLink,
    required TResult Function(LexUnknown data) unknown,
  }) {
    return bytes(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LexRecord data)? record,
    TResult? Function(LexXrpcQuery data)? xrpcQuery,
    TResult? Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult? Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult? Function(LexBlob data)? blob,
    TResult? Function(LexArray data)? array,
    TResult? Function(LexToken data)? token,
    TResult? Function(LexObject data)? object,
    TResult? Function(LexBoolean data)? boolean,
    TResult? Function(LexInteger data)? integer,
    TResult? Function(LexString data)? string,
    TResult? Function(LexBytes data)? bytes,
    TResult? Function(LexCidLink data)? cidLink,
    TResult? Function(LexUnknown data)? unknown,
  }) {
    return bytes?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LexRecord data)? record,
    TResult Function(LexXrpcQuery data)? xrpcQuery,
    TResult Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult Function(LexBlob data)? blob,
    TResult Function(LexArray data)? array,
    TResult Function(LexToken data)? token,
    TResult Function(LexObject data)? object,
    TResult Function(LexBoolean data)? boolean,
    TResult Function(LexInteger data)? integer,
    TResult Function(LexString data)? string,
    TResult Function(LexBytes data)? bytes,
    TResult Function(LexCidLink data)? cidLink,
    TResult Function(LexUnknown data)? unknown,
    required TResult orElse(),
  }) {
    if (bytes != null) {
      return bytes(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ULexUserTypeRecord value) record,
    required TResult Function(ULexUserTypeXrpcQuery value) xrpcQuery,
    required TResult Function(ULexUserTypeXrpcProcedure value) xrpcProcedure,
    required TResult Function(ULexUserTypeXrpcSubscription value)
        xrpcSubscription,
    required TResult Function(ULexUserTypeBlob value) blob,
    required TResult Function(ULexUserTypeArray value) array,
    required TResult Function(ULexUserTypeToken value) token,
    required TResult Function(ULexUserTypeObject value) object,
    required TResult Function(ULexUserTypeBoolean value) boolean,
    required TResult Function(ULexUserTypeInteger value) integer,
    required TResult Function(ULexUserTypeString value) string,
    required TResult Function(ULexUserTypeBytes value) bytes,
    required TResult Function(ULexUserTypeCidLink value) cidLink,
    required TResult Function(ULexUserTypeUnknown value) unknown,
  }) {
    return bytes(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ULexUserTypeRecord value)? record,
    TResult? Function(ULexUserTypeXrpcQuery value)? xrpcQuery,
    TResult? Function(ULexUserTypeXrpcProcedure value)? xrpcProcedure,
    TResult? Function(ULexUserTypeXrpcSubscription value)? xrpcSubscription,
    TResult? Function(ULexUserTypeBlob value)? blob,
    TResult? Function(ULexUserTypeArray value)? array,
    TResult? Function(ULexUserTypeToken value)? token,
    TResult? Function(ULexUserTypeObject value)? object,
    TResult? Function(ULexUserTypeBoolean value)? boolean,
    TResult? Function(ULexUserTypeInteger value)? integer,
    TResult? Function(ULexUserTypeString value)? string,
    TResult? Function(ULexUserTypeBytes value)? bytes,
    TResult? Function(ULexUserTypeCidLink value)? cidLink,
    TResult? Function(ULexUserTypeUnknown value)? unknown,
  }) {
    return bytes?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ULexUserTypeRecord value)? record,
    TResult Function(ULexUserTypeXrpcQuery value)? xrpcQuery,
    TResult Function(ULexUserTypeXrpcProcedure value)? xrpcProcedure,
    TResult Function(ULexUserTypeXrpcSubscription value)? xrpcSubscription,
    TResult Function(ULexUserTypeBlob value)? blob,
    TResult Function(ULexUserTypeArray value)? array,
    TResult Function(ULexUserTypeToken value)? token,
    TResult Function(ULexUserTypeObject value)? object,
    TResult Function(ULexUserTypeBoolean value)? boolean,
    TResult Function(ULexUserTypeInteger value)? integer,
    TResult Function(ULexUserTypeString value)? string,
    TResult Function(ULexUserTypeBytes value)? bytes,
    TResult Function(ULexUserTypeCidLink value)? cidLink,
    TResult Function(ULexUserTypeUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (bytes != null) {
      return bytes(this);
    }
    return orElse();
  }
}

abstract class ULexUserTypeBytes extends LexUserType {
  const factory ULexUserTypeBytes({required final LexBytes data}) =
      _$ULexUserTypeBytesImpl;
  const ULexUserTypeBytes._() : super._();

  @override
  LexBytes get data;

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ULexUserTypeBytesImplCopyWith<_$ULexUserTypeBytesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ULexUserTypeCidLinkImplCopyWith<$Res> {
  factory _$$ULexUserTypeCidLinkImplCopyWith(_$ULexUserTypeCidLinkImpl value,
          $Res Function(_$ULexUserTypeCidLinkImpl) then) =
      __$$ULexUserTypeCidLinkImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LexCidLink data});

  $LexCidLinkCopyWith<$Res> get data;
}

/// @nodoc
class __$$ULexUserTypeCidLinkImplCopyWithImpl<$Res>
    extends _$LexUserTypeCopyWithImpl<$Res, _$ULexUserTypeCidLinkImpl>
    implements _$$ULexUserTypeCidLinkImplCopyWith<$Res> {
  __$$ULexUserTypeCidLinkImplCopyWithImpl(_$ULexUserTypeCidLinkImpl _value,
      $Res Function(_$ULexUserTypeCidLinkImpl) _then)
      : super(_value, _then);

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$ULexUserTypeCidLinkImpl(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as LexCidLink,
    ));
  }

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LexCidLinkCopyWith<$Res> get data {
    return $LexCidLinkCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc

class _$ULexUserTypeCidLinkImpl extends ULexUserTypeCidLink {
  const _$ULexUserTypeCidLinkImpl({required this.data}) : super._();

  @override
  final LexCidLink data;

  @override
  String toString() {
    return 'LexUserType.cidLink(data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ULexUserTypeCidLinkImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ULexUserTypeCidLinkImplCopyWith<_$ULexUserTypeCidLinkImpl> get copyWith =>
      __$$ULexUserTypeCidLinkImplCopyWithImpl<_$ULexUserTypeCidLinkImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LexRecord data) record,
    required TResult Function(LexXrpcQuery data) xrpcQuery,
    required TResult Function(LexXrpcProcedure data) xrpcProcedure,
    required TResult Function(LexXrpcSubscription data) xrpcSubscription,
    required TResult Function(LexBlob data) blob,
    required TResult Function(LexArray data) array,
    required TResult Function(LexToken data) token,
    required TResult Function(LexObject data) object,
    required TResult Function(LexBoolean data) boolean,
    required TResult Function(LexInteger data) integer,
    required TResult Function(LexString data) string,
    required TResult Function(LexBytes data) bytes,
    required TResult Function(LexCidLink data) cidLink,
    required TResult Function(LexUnknown data) unknown,
  }) {
    return cidLink(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LexRecord data)? record,
    TResult? Function(LexXrpcQuery data)? xrpcQuery,
    TResult? Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult? Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult? Function(LexBlob data)? blob,
    TResult? Function(LexArray data)? array,
    TResult? Function(LexToken data)? token,
    TResult? Function(LexObject data)? object,
    TResult? Function(LexBoolean data)? boolean,
    TResult? Function(LexInteger data)? integer,
    TResult? Function(LexString data)? string,
    TResult? Function(LexBytes data)? bytes,
    TResult? Function(LexCidLink data)? cidLink,
    TResult? Function(LexUnknown data)? unknown,
  }) {
    return cidLink?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LexRecord data)? record,
    TResult Function(LexXrpcQuery data)? xrpcQuery,
    TResult Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult Function(LexBlob data)? blob,
    TResult Function(LexArray data)? array,
    TResult Function(LexToken data)? token,
    TResult Function(LexObject data)? object,
    TResult Function(LexBoolean data)? boolean,
    TResult Function(LexInteger data)? integer,
    TResult Function(LexString data)? string,
    TResult Function(LexBytes data)? bytes,
    TResult Function(LexCidLink data)? cidLink,
    TResult Function(LexUnknown data)? unknown,
    required TResult orElse(),
  }) {
    if (cidLink != null) {
      return cidLink(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ULexUserTypeRecord value) record,
    required TResult Function(ULexUserTypeXrpcQuery value) xrpcQuery,
    required TResult Function(ULexUserTypeXrpcProcedure value) xrpcProcedure,
    required TResult Function(ULexUserTypeXrpcSubscription value)
        xrpcSubscription,
    required TResult Function(ULexUserTypeBlob value) blob,
    required TResult Function(ULexUserTypeArray value) array,
    required TResult Function(ULexUserTypeToken value) token,
    required TResult Function(ULexUserTypeObject value) object,
    required TResult Function(ULexUserTypeBoolean value) boolean,
    required TResult Function(ULexUserTypeInteger value) integer,
    required TResult Function(ULexUserTypeString value) string,
    required TResult Function(ULexUserTypeBytes value) bytes,
    required TResult Function(ULexUserTypeCidLink value) cidLink,
    required TResult Function(ULexUserTypeUnknown value) unknown,
  }) {
    return cidLink(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ULexUserTypeRecord value)? record,
    TResult? Function(ULexUserTypeXrpcQuery value)? xrpcQuery,
    TResult? Function(ULexUserTypeXrpcProcedure value)? xrpcProcedure,
    TResult? Function(ULexUserTypeXrpcSubscription value)? xrpcSubscription,
    TResult? Function(ULexUserTypeBlob value)? blob,
    TResult? Function(ULexUserTypeArray value)? array,
    TResult? Function(ULexUserTypeToken value)? token,
    TResult? Function(ULexUserTypeObject value)? object,
    TResult? Function(ULexUserTypeBoolean value)? boolean,
    TResult? Function(ULexUserTypeInteger value)? integer,
    TResult? Function(ULexUserTypeString value)? string,
    TResult? Function(ULexUserTypeBytes value)? bytes,
    TResult? Function(ULexUserTypeCidLink value)? cidLink,
    TResult? Function(ULexUserTypeUnknown value)? unknown,
  }) {
    return cidLink?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ULexUserTypeRecord value)? record,
    TResult Function(ULexUserTypeXrpcQuery value)? xrpcQuery,
    TResult Function(ULexUserTypeXrpcProcedure value)? xrpcProcedure,
    TResult Function(ULexUserTypeXrpcSubscription value)? xrpcSubscription,
    TResult Function(ULexUserTypeBlob value)? blob,
    TResult Function(ULexUserTypeArray value)? array,
    TResult Function(ULexUserTypeToken value)? token,
    TResult Function(ULexUserTypeObject value)? object,
    TResult Function(ULexUserTypeBoolean value)? boolean,
    TResult Function(ULexUserTypeInteger value)? integer,
    TResult Function(ULexUserTypeString value)? string,
    TResult Function(ULexUserTypeBytes value)? bytes,
    TResult Function(ULexUserTypeCidLink value)? cidLink,
    TResult Function(ULexUserTypeUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (cidLink != null) {
      return cidLink(this);
    }
    return orElse();
  }
}

abstract class ULexUserTypeCidLink extends LexUserType {
  const factory ULexUserTypeCidLink({required final LexCidLink data}) =
      _$ULexUserTypeCidLinkImpl;
  const ULexUserTypeCidLink._() : super._();

  @override
  LexCidLink get data;

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ULexUserTypeCidLinkImplCopyWith<_$ULexUserTypeCidLinkImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ULexUserTypeUnknownImplCopyWith<$Res> {
  factory _$$ULexUserTypeUnknownImplCopyWith(_$ULexUserTypeUnknownImpl value,
          $Res Function(_$ULexUserTypeUnknownImpl) then) =
      __$$ULexUserTypeUnknownImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LexUnknown data});

  $LexUnknownCopyWith<$Res> get data;
}

/// @nodoc
class __$$ULexUserTypeUnknownImplCopyWithImpl<$Res>
    extends _$LexUserTypeCopyWithImpl<$Res, _$ULexUserTypeUnknownImpl>
    implements _$$ULexUserTypeUnknownImplCopyWith<$Res> {
  __$$ULexUserTypeUnknownImplCopyWithImpl(_$ULexUserTypeUnknownImpl _value,
      $Res Function(_$ULexUserTypeUnknownImpl) _then)
      : super(_value, _then);

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$ULexUserTypeUnknownImpl(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as LexUnknown,
    ));
  }

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $LexUnknownCopyWith<$Res> get data {
    return $LexUnknownCopyWith<$Res>(_value.data, (value) {
      return _then(_value.copyWith(data: value));
    });
  }
}

/// @nodoc

class _$ULexUserTypeUnknownImpl extends ULexUserTypeUnknown {
  const _$ULexUserTypeUnknownImpl({required this.data}) : super._();

  @override
  final LexUnknown data;

  @override
  String toString() {
    return 'LexUserType.unknown(data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ULexUserTypeUnknownImpl &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ULexUserTypeUnknownImplCopyWith<_$ULexUserTypeUnknownImpl> get copyWith =>
      __$$ULexUserTypeUnknownImplCopyWithImpl<_$ULexUserTypeUnknownImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(LexRecord data) record,
    required TResult Function(LexXrpcQuery data) xrpcQuery,
    required TResult Function(LexXrpcProcedure data) xrpcProcedure,
    required TResult Function(LexXrpcSubscription data) xrpcSubscription,
    required TResult Function(LexBlob data) blob,
    required TResult Function(LexArray data) array,
    required TResult Function(LexToken data) token,
    required TResult Function(LexObject data) object,
    required TResult Function(LexBoolean data) boolean,
    required TResult Function(LexInteger data) integer,
    required TResult Function(LexString data) string,
    required TResult Function(LexBytes data) bytes,
    required TResult Function(LexCidLink data) cidLink,
    required TResult Function(LexUnknown data) unknown,
  }) {
    return unknown(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(LexRecord data)? record,
    TResult? Function(LexXrpcQuery data)? xrpcQuery,
    TResult? Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult? Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult? Function(LexBlob data)? blob,
    TResult? Function(LexArray data)? array,
    TResult? Function(LexToken data)? token,
    TResult? Function(LexObject data)? object,
    TResult? Function(LexBoolean data)? boolean,
    TResult? Function(LexInteger data)? integer,
    TResult? Function(LexString data)? string,
    TResult? Function(LexBytes data)? bytes,
    TResult? Function(LexCidLink data)? cidLink,
    TResult? Function(LexUnknown data)? unknown,
  }) {
    return unknown?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(LexRecord data)? record,
    TResult Function(LexXrpcQuery data)? xrpcQuery,
    TResult Function(LexXrpcProcedure data)? xrpcProcedure,
    TResult Function(LexXrpcSubscription data)? xrpcSubscription,
    TResult Function(LexBlob data)? blob,
    TResult Function(LexArray data)? array,
    TResult Function(LexToken data)? token,
    TResult Function(LexObject data)? object,
    TResult Function(LexBoolean data)? boolean,
    TResult Function(LexInteger data)? integer,
    TResult Function(LexString data)? string,
    TResult Function(LexBytes data)? bytes,
    TResult Function(LexCidLink data)? cidLink,
    TResult Function(LexUnknown data)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ULexUserTypeRecord value) record,
    required TResult Function(ULexUserTypeXrpcQuery value) xrpcQuery,
    required TResult Function(ULexUserTypeXrpcProcedure value) xrpcProcedure,
    required TResult Function(ULexUserTypeXrpcSubscription value)
        xrpcSubscription,
    required TResult Function(ULexUserTypeBlob value) blob,
    required TResult Function(ULexUserTypeArray value) array,
    required TResult Function(ULexUserTypeToken value) token,
    required TResult Function(ULexUserTypeObject value) object,
    required TResult Function(ULexUserTypeBoolean value) boolean,
    required TResult Function(ULexUserTypeInteger value) integer,
    required TResult Function(ULexUserTypeString value) string,
    required TResult Function(ULexUserTypeBytes value) bytes,
    required TResult Function(ULexUserTypeCidLink value) cidLink,
    required TResult Function(ULexUserTypeUnknown value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ULexUserTypeRecord value)? record,
    TResult? Function(ULexUserTypeXrpcQuery value)? xrpcQuery,
    TResult? Function(ULexUserTypeXrpcProcedure value)? xrpcProcedure,
    TResult? Function(ULexUserTypeXrpcSubscription value)? xrpcSubscription,
    TResult? Function(ULexUserTypeBlob value)? blob,
    TResult? Function(ULexUserTypeArray value)? array,
    TResult? Function(ULexUserTypeToken value)? token,
    TResult? Function(ULexUserTypeObject value)? object,
    TResult? Function(ULexUserTypeBoolean value)? boolean,
    TResult? Function(ULexUserTypeInteger value)? integer,
    TResult? Function(ULexUserTypeString value)? string,
    TResult? Function(ULexUserTypeBytes value)? bytes,
    TResult? Function(ULexUserTypeCidLink value)? cidLink,
    TResult? Function(ULexUserTypeUnknown value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ULexUserTypeRecord value)? record,
    TResult Function(ULexUserTypeXrpcQuery value)? xrpcQuery,
    TResult Function(ULexUserTypeXrpcProcedure value)? xrpcProcedure,
    TResult Function(ULexUserTypeXrpcSubscription value)? xrpcSubscription,
    TResult Function(ULexUserTypeBlob value)? blob,
    TResult Function(ULexUserTypeArray value)? array,
    TResult Function(ULexUserTypeToken value)? token,
    TResult Function(ULexUserTypeObject value)? object,
    TResult Function(ULexUserTypeBoolean value)? boolean,
    TResult Function(ULexUserTypeInteger value)? integer,
    TResult Function(ULexUserTypeString value)? string,
    TResult Function(ULexUserTypeBytes value)? bytes,
    TResult Function(ULexUserTypeCidLink value)? cidLink,
    TResult Function(ULexUserTypeUnknown value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class ULexUserTypeUnknown extends LexUserType {
  const factory ULexUserTypeUnknown({required final LexUnknown data}) =
      _$ULexUserTypeUnknownImpl;
  const ULexUserTypeUnknown._() : super._();

  @override
  LexUnknown get data;

  /// Create a copy of LexUserType
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ULexUserTypeUnknownImplCopyWith<_$ULexUserTypeUnknownImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
